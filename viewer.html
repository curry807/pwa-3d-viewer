
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="styles.css">
  <style>
    #canvas-wrap { position: relative; height: 70vh; background: #111; border-radius: 12px; overflow: hidden; }
    canvas { display:block; width:100%; height:100%; }
    .toolbar { margin-top: 12px; display:flex; gap:8px; flex-wrap:wrap; }
    .dropzone { border: 2px dashed #ff8ac2; border-radius:12px; padding:12px; text-align:center; color:#666; }
  </style>
</head>
<body>
  <header class="app-header">
    <h1>3Dビューア</h1>
    <p>GLB/GLTFファイルを開いてください（ドラッグ＆ドロップ可）。</p>
  </header>

  <main>
    <div id="canvas-wrap"></div>
    <div class="toolbar">
      <label class="btn">
        ファイルを開く
        <input id="file-input" type="file" accept=".glb,.gltf" style="display:none">
      </label>
      <button id="reset" class="btn">リセット</button>
      <button id="bg" class="btn">背景：明→暗</button>
    </div>
    <div id="dropzone" class="dropzone">ここに <strong>GLB/GLTF</strong> をドラッグ＆ドロップ</div>
  </main>

  <!-- Three.js & loaders via module import -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { KTX2Loader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/KTX2Loader.js';

    const wrap = document.getElementById('canvas-wrap');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeeeeee);

    const camera = new THREE.PerspectiveCamera(60, wrap.clientWidth / wrap.clientHeight, 0.1, 1000);
    camera.position.set(2, 2, 2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    hemi.position.set(0, 1, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(3, 5, 2);
    scene.add(dir);

    const grid = new THREE.GridHelper(10, 10);
    scene.add(grid);

    // KTX2 loader setup (optional, works if KTX2 assets are used)
    const ktx2Loader = new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/');

    const gltfLoader = new GLTFLoader();
    gltfLoader.setKTX2Loader(ktx2Loader);

    let currentScene = null;

    function loadArrayBuffer(arrayBuffer, filename = 'model') {
      const blob = new Blob([arrayBuffer]);
      const url = URL.createObjectURL(blob);
      if (filename.endsWith('.glb')) {
        gltfLoader.load(url, (gltf) => {
          if (currentScene) scene.remove(currentScene);
          currentScene = gltf.scene;
          scene.add(currentScene);
          fitToView(currentScene);
          URL.revokeObjectURL(url);
        }, undefined, (e) => { console.error(e); URL.revokeObjectURL(url); });
      } else if (filename.endsWith('.gltf')) {
        // For .gltf with external resources, direct Blob may not resolve; recommend GLB for portability.
        gltfLoader.load(url, (gltf) => {
          if (currentScene) scene.remove(currentScene);
          currentScene = gltf.scene;
          scene.add(currentScene);
          fitToView(currentScene);
          URL.revokeObjectURL(url);
        }, undefined, (e) => { console.error(e); URL.revokeObjectURL(url); });
      } else {
        alert('対応形式は .glb / .gltf です');
      }
    }

    function fitToView(object3d) {
      const box = new THREE.Box3().setFromObject(object3d);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let distance = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
      distance = Math.max(distance, 2);
      camera.position.copy(center).add(new THREE.Vector3(distance, distance, distance));
      camera.near = distance / 100;
      camera.far = distance * 20;
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
      camera.aspect = wrap.clientWidth / wrap.clientHeight;
      camera.updateProjectionMatrix();
    });

    // File input
    const input = document.getElementById('file-input');
    input.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const buf = await file.arrayBuffer();
      loadArrayBuffer(buf, file.name.toLowerCase());
    });

    // Drag & drop
    const drop = document.getElementById('dropzone');
    ['dragenter','dragover'].forEach(evt => drop.addEventListener(evt, (e)=>{e.preventDefault(); drop.style.background='#fff0f7';}));
    ['dragleave','drop'].forEach(evt => drop.addEventListener(evt, (e)=>{e.preventDefault(); drop.style.background='';}));
    drop.addEventListener('drop', async (e) => {
      const file = e.dataTransfer.files[0];
      if (!file) return;
      const buf = await file.arrayBuffer();
      loadArrayBuffer(buf, file.name.toLowerCase());
    });

    // UI buttons
    document.getElementById('reset').onclick = () => {
      controls.reset();
    };
    document.getElementById('bg').onclick = () => {
      const c = scene.background.getHex();
      scene.background = new THREE.Color(c === 0xeeeeee ? 0x111111 : 0xeeeeee);
    };
  </script>
</body>
</html>
